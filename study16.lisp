(load "study15.lisp")
(defun pairs (lst)
  (labels ((f (lst acc)
             (split lst
                    (if tail
                        (f (cdr tail) (cons (cons head (car tail)) acc))
                        (reverse acc))
                    (reverse acc))))
    (f lst nil)))
(defun print-tag (name alst closingp)
  (princ #\<)
  (when closingp
    (princ #\/))
  (princ (string-downcase name))
  (mapc (lambda (att)
          (format t " ~a=\"~a\"" (string-downcase (car att)) (cdr att)))
        alst)
  (princ #\>))
(defmacro tag (name atts &body body)
  `(progn (print-tag ',name
                    (list ,@(mapcar (lambda (x)
                                       `(cons ',(car x) ,(cdr x)))
                                     (pairs atts)))
                    nil)
          ,@body
          (print-tag ',name nil t)))

(defmacro tag2 (name atts &body body)
  `(progn (printtag ',name
                    ',(mapcar (lambda (x)
                                       `(cons ',(car x) ,(cdr x)))
                                     (pairs atts))
                    nil)
          ,@body
          (print-tag ',name nil t)))
(defmacro html (&body body)
  `(tag html ()
     ,@body))
(defmacro body (&body body)
  `(tag body ()
     ,@body))
(defmacro svg (width height &body body)
  `(tag svg (xmlns "http://www.w3.org/2000/svg"
                   "xmlns:xlink" "http://www.w3.org/1999/xlink" height ,height width ,width)
     ,@body))
(defun brightness (col amt)
  (mapcar (lambda (x)
            (min 255 (max 0 (+ x amt))))
          col))
(defun svg-style (color)
  (format nil
          "~{fill:rgb(~a,~a,~a};stroke:rgb(~a,~a,~a)~}"
          (append color
                  (brightness color -100))))
(defun circle (center radius color)
  (tag circle (cx (car center)
                  cy (cdr center)
                  r radius
                  style (svg-style color))))
(defun polygon (points color)
  (tag polygon (points (format nil
                               "~{~a,~a ~}"
                               (mapcan (lambda (tp)
                                         (list (car tp) (cdr tp)))
                                       points))
                       style (svg-style color))))
(defun random-walk (value length)
  (unless (zerop length)
    (cons value
          (random-walk (if (zerop (random 2))
                           (1- value)
                           (1+ value))
                       (1- length)))))
(with-open-file (*standard-output* "random_walk.svg"
                                   :direction :output
                                   :if-exists :supersede)
  (svg 400 200 (loop repeat 10
                     do (polygon (append '((0 . 200))
                                         (loop for x from 0 below 400
                                               for y in (random-walk 100 400)
                                               collect (cons x y))
                                         '((400 . 200)))
                                 (loop repeat 3
                                       collect (random 256))))))
(defmacro lazy (&body body)
  (let ((forced (gensym))
        (value (gensym)))
    `(let ((,forced nil)
           (,value nil))
       (lambda ()
         (unless ,forced
           (setf ,value (progn ,@body))
           (setf ,forced t))
         ,value))))
(defun force (lazy-value)
  (funcall lazy-value))
(defmacro lazy-cons (a d)
  `(lazy (cons ,a ,d)))
(defun lazy-car (x)
  (car (force x)))
(defun lazy-cdr (x)
  (cdr (force x)))
;; (defparameter *integers*
;;   (labels ((f (n)
;;              (lazy-cons n (f (1+ n)))))
;;     (f 1)))
(defun lazy-nil ()
  (lazy nil))
(defun lazy-null (x)
  (not (force x)))
(defun make-lazy (lst)
  (lazy (when lst
          (cons (car lst) (make-lazy (cdr lst))))))
(defun take (n lst)
  (unless (or (zerop n) (lazy-null lst))
    (cons (lazy-car lst) (take (1- n) (lazy-cdr lst)))))
(defun take-all (lst)
  (unless (lazy-null lst)
    (cons (lazy-car lst) (take-all (lazy-cdr lst)))))
(defun lazy-mapcar (fun lst)
  (lazy (unless (lazy-null lst)
          (cosn (funcall fun (lazy-car lst))
                (lazy-mapcar fun (lazy-cdr lst))))))
(defun lazy-mapcan (fun lst)
  (labels ((f (lst-cur)
             (if (lazy-null lst-cur)
                 (force (lazy-mapcan fun (lazy-cdr lst)))
                 (cons (lazy-car lst-cur) (lazy (f (lazy-cdr lst-cur)))))))
    (lazy (unless (lazy-null lst)
            (f (funcall fun (lazy-car lst)))))))
(defun lazy-find-if (fun lst)
  (unless (lazy-null lst)
    (let ((x (lazy-car lst)))
      (if (funcall fun x)
          x
          (lazy-find-if fun (lazy-cdr lst))))))
(defun lazy-nth (n lst)
  (if (zerop n)
      (lazy-car lst)
      (lazy-nth (1- n) (lazy-cdr lst))))
